// MUMT 307 (Music & Audio Computing II)
// Final Project: Model Analysis and Resynthesis Engine
// Max Henry #260133798

/*
 
 This is the second part of a two part engine for model analysis and resynthesis.
 It accepts values from a CSV file generated by the accompanying modal analysis
 MATLAB script.
 
 This code uses the extracted frequencies and radii to construct a filter bank
 that can be dynamically altered by transposition and velocity values to generate,
 in effect, a synthesis engine from a single sampled note.
 
 Eventually this script should be altered to accept midi input in real time.  For
 now it is in two parts: (i) filterbank construction, (ii) sound generation, i.e.
 running an impulse through a scaled and shifted filter bank.  In time, realtime
 midi information can be used to trigger this second part.
 
 EXTRA GOALS::
 global gain -- overload protection?
 midi implementation?
 
 */

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <cmath>
#include "BiQuad.h"
#include "RtWvOut.h"
#include "Asymp.h"


using namespace stk;

// Define class for filter parameters, to be used in a vector below.
class filtParam {
public:
    float freq, R, gain;
};

std::vector<filtParam> getFiltParams(std::string filename) {
    // Function to get filter variables from csv file.
    
    std::fstream fin;
    fin.open(filename, std::ios::in);
    std::string line, word;
    float temp;
    
    std::vector<filtParam> filtParams;
    
    for ( int i = 0; i < 3; i++ ) {
        getline(fin, line);
        std::stringstream s(line);
        
        int j = 0;
        
        // Sort filter data by type: Frequency, R values, and gains.
        while ( getline(s, word, ',') ) {
            temp = stof(word);
            
            if (i == 0){
                filtParam fp;
                fp.freq = temp;
                filtParams.push_back(fp);
            }
            else if ( i == 1 ) {
                filtParams[j].R = temp;
                j++;
            }
            else if ( i == 2 ) {
                filtParams[j].gain = temp;
                j++;
            }
        }
    }
    
    // Report input.
    std::cout << filtParams.size() << " modes total:" << std::endl;
    
    for (int j = 0; j < filtParams.size(); j++ ) {
        std::cout << "Filter " << j + 1 << "-- Frequency = " << filtParams[j].freq << " R = " << filtParams[j].R << " gain = " << filtParams[j].gain << std::endl;
        
    }
    
    return filtParams;
}

// Error and quitting procedure.
int erquit(){
    std::cout << "---------------- usage: notein noteout velocity duration ----------------" << std::endl;
    std::cout << "notein is the midi pitch value of the given sample (0 - 127)" << std::endl;
    std::cout << "noteout is the desired output midi pitch (0 - 127)" << std::endl;
    std::cout << "velocity is a value from (0 - 127)" << std::endl;
    std::cout << "duration is the sustain length of the note in seconds from (0.2 - 6.0)"<< std::endl;
    exit(0);
}


int main( int argc, char *argv[] ) {

    StkFloat fs = 44100.0;
    Stk::setSampleRate( fs );
    
    // Stereo output.
    RtWvOut dac( 2 );
    StkFloat output;
    
    // Accept command line inputs and check for errors.
    float notein, noteout, velocity, noteDur;
    notein = ( (atof(argv[1]) <= 127.0) && (atof(argv[1]) >= 0.0) ) ? atof(argv[1]) : erquit();
    noteout = ( (atof(argv[2]) <= 127.0) && (atof(argv[2]) >= 0.0) ) ? atof(argv[2]) : erquit();
    velocity = ( (atof(argv[3]) <= 127.0) && (atof(argv[3]) >= 0.0) ) ? atof(argv[3]) : erquit();
    noteDur = ( (atof(argv[4]) <= 6.0) && (atof(argv[4]) >=0.2) ) ? atof(argv[4]) : erquit();
    
    // Calculate output transposition.
    float transpose = pow( 2, ((noteout - notein)/12.0) );
    
    // Read the specified frequency values from Matlab output (frequency, r, and gain).
    std::vector<filtParam> filts = getFiltParams("FreqsRs.csv");
    
    //      Build filters and scale values based on specifications:
    //
    //  Frequencies are scaled based on the transposition value
    //  Overtone coefficients for filter gains are based on input velocity.
    //  (Lower velocity -> less gain for overtones -> duller output.)

    float numFilts = filts.size();
    float filtNormalizer = 1.0/numFilts;
    float nyquistbuffer;
    float velopitch;
    
    std::vector<BiQuad> resonator (numFilts);
    std::vector<float> overtoneCurve( numFilts );
    std::vector<float> nyquistgain( numFilts, 1.0 );
    
    // Stretch factor for scaling velocity curve by midi note (higher note --> limited velocity --> less overtones).
    float stretch = ( notein/noteout < 1.0 ) ? (notein/noteout) : 1.0;
    
    // Setting filter specific scaling: including frequency and gain values.
    for (float i = 0; i < numFilts; i++ ) {
        
        // Check for frequencies above nyquist, and set corresponding gain to 0 if necessary.
        nyquistbuffer = transpose * filts[i].freq;
        if ( nyquistbuffer >= fs/2.0 )
            nyquistgain[i] = 0;
        
        // Set frequency and r value.
        resonator[i].setResonance( nyquistbuffer, filts[i].R, true );
        
        // Calculate overtone curve, based on velocity.
        overtoneCurve[i] = pow( (stretch * velocity/127.0), (i/numFilts * 5.0) );

    }
    
    // Amplitude envelope settings and calculations.
    float attack = 0.1;
    float sustain = 10 * pow( stretch, 1.5 );
    float release = 0.4;
    int dur = (noteDur + release) * fs;
    
    Asymp ampEnv;
    ampEnv.setTime( attack );
    ampEnv.keyOn();
    
    // Initialize impulse signal.
    StkFloat impulse = 1.0;
    
    for (int i = 0; i < dur; i++ ) {
        if (i > 0)
            impulse = 0;
        
        if (i > noteDur * fs) {
            ampEnv.setTime( release );
            ampEnv.keyOff();
        }
        else if (i > attack * fs) {
            ampEnv.setTime( sustain );
            ampEnv.keyOff();
        }
            
        //      Additive cycle through resonant filters:
        //
        //  filtNormalizer scales the gain by the total number of filters
        //  nyquistgain turns off filters above nyquist.
        //  overtoneCurve scales filters by input velocity (quieter notes de-emphasize higher filters)
        //  filts.gain is the original gain as specified by the Matlab analysis
        
        for (int j = 0; j < numFilts; j++ ) {
            output = output + filtNormalizer * nyquistgain[j] * overtoneCurve[j] * filts[j].gain * resonator[j].tick( impulse );
        }
        
        output = 40000 * ampEnv.tick() * output;
        
        dac.tick( output );
        output = 0;
    }

    return 0;
}
